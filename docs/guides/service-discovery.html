<!doctype html>
<html>
<head>
  <title>KillrVideo - Service Discovery with etcd</title>
  <link href="/assets/bundle.css" rel="stylesheet">
  <link rel="icon" type="image/png" href="/assets/images/killrvideo-icon.png"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  
  <header>
    <nav class="nav">
      <div class="container">
        <div class="nav-left">
          <a href="/" class="nav-item">
            <img src="/assets/images/killrvideo.png" alt="KillrVideo logo" />
          </a>
        </div>

        <!-- Nav Toggle on mobile -->
        <span class="nav-toggle">
          <span></span>
          <span></span>
          <span></span>
        </span>

        <div class="nav-right nav-menu">
          <span class="nav-item">
            <a href="/docs/guides/getting-started.html" class="button is-primary">
              <i class="fa fa-code fa-fw"></i> Get Started
            </a>
          </span>
          <a href="/docs" class="nav-item">
            Docs
          </a>
          <a href="/blog" class="nav-item">
            Blog
          </a>
          <a href="https://github.com/KillrVideo" target="_blank" class="nav-item">
            <i class="fa fa-github fa-2x"></i>
          </a>
        </div>
      </div>
    </nav>
  </header>

  
  
<section class="section">
  <div class="container">
    <div class="columns">
      <article class="column is-9 content">
        <h1 id="service-discovery-with-etcd">Service Discovery with etcd</h1>
<p>One problem all microservices architectures face is how to do service discovery. How does
the Video Catalog service know where to go to talk to Cassandra? How does the Web Tier know
where to talk to the Video Catalog service? There are really two parts to the common way of 
solving this problem:</p>
<ol>
<li>Service Registration: We need well-known location and some mechanism to register the
location of services.</li>
<li>Service Discovery: We need some way to query the location of services.</li>
</ol>
<p>In KillrVideo, we decided to use <a href="https://github.com/coreos/etcd">etcd</a> as our service registry. At its most basic, 
etcd is just a distributed, consistent, key-value store. The <a href="https://github.com/coreos/etcd/blob/master/Documentation/v2/README.md">v2 API</a> which we currently
use to interact with etcd is just simple curlable HTTP API (funny enough, the <a href="https://github.com/coreos/etcd/blob/master/Documentation/dev-guide/api_reference_v3.md">v3 API</a>
for etcd is all based on Protocol Buffers and Grpc just like KillrVideo).</p>
<p>As mentioned in the <a href="./docker.md">previous section on Docker</a>, we use a program called 
<a href="http://gliderlabs.com/registrator/latest/">Registrator</a> to take care of automatically registering our services running in
containers with etcd. This means that our DataStax Enterprise node, for example, will
automatically be registered with etcd whenever its container is started.</p>
<h2 id="querying-etcd">Querying etcd</h2>
<p>All KillrVideo data is stored under <code>/killrvideo</code> in etcd. This means that the base URL for
queries to the v2 API in <a href="https://github.com/coreos/etcd">etcd</a> is:</p>
<pre><code>http://${SOME_IP_ADDRESS}:2379/v2/keys/killrvideo
</code></pre><p>For service registrations, we put that data under <code>/services/${SERVICE_NAME}</code>. So, for
example, when trying to find the location of the <em>cassandra</em> service we&#39;d make a <code>GET</code> 
request to:</p>
<pre><code>http://${SOME_IP_ADDRESS}:2379/v2/keys/killrvideo/services/cassandra
</code></pre><p>For more details on the response returned from this call, check out the <a href="https://github.com/coreos/etcd/blob/master/Documentation/v2/README.md">v2 API documentation</a>.</p>
<h2 id="registering-services-in-etcd">Registering services in etcd</h2>
<p>While <a href="http://gliderlabs.com/registrator/latest/">Registrator</a> takes care of registering the things running in containers
for us, what about the microservice code running on a local developer machine? The Web Tier,
for example, is going to need to know where to call the various microservices. For the
microservice implementations, we leave service registration with <a href="https://github.com/coreos/etcd">etcd</a> up to each
implementation&#39;s code. This isn&#39;t terribly complicated code though. Usually it just means
that when the microservices start, they make a <code>PUT</code> request to the same URL we would use to
lookup a service with the IP address they&#39;re listening on. For example, the Video Catalog 
service would use:</p>
<pre><code>http://${SOME_IP_ADDRESS}:2379/v2/keys/killrvideo/services/VideoCatalogService
</code></pre><blockquote>
<h3 id="note-on-grpc-service-naming-conventions">Note on Grpc Service Naming Conventions</h3>
<p>All of the services defined in Protocol Buffers for use with Grpc use the service&#39;s &quot;short
name&quot; when registering with etcd. The short name for a service is the same name used in
<code>.proto</code> file and excludes the namespace.</p>
</blockquote>
<p>Again, for more details on the exact API request and response, see the <a href="https://github.com/coreos/etcd/blob/master/Documentation/v2/README.md">v2 API documentation</a>.</p>

      </article>
      <nav class="column is-3">
        <ul>
          
          <li class="link-list-item">
            <a href="/docs/guides/docker.html">Docker and Infrastructure Dependencies</a>
            <ul>
            
              <li class="link-list-item">
                <a href="/docs/guides/docker.html#docker-compose-for-starting-dependencies">Docker Compose for Starting Dependencies</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/docker.html#docker-environment-scripts">Docker Environment Scripts</a>
              </li>
            
            </ul>
          </li>
          
          <li class="link-list-item">
            <a href="/docs/guides/architecture.html">High Level Architecture Overview</a>
            <ul>
            
              <li class="link-list-item">
                <a href="/docs/guides/architecture.html#microservices-tier">Microservices Tier</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/architecture.html#using-events-for-service-collaboration">Using Events for Service Collaboration</a>
              </li>
            
            </ul>
          </li>
          
          <li class="link-list-item">
            <a href="/docs/guides/microservices-tier.html">Microservice Tier Implementation</a>
            <ul>
            
              <li class="link-list-item">
                <a href="/docs/guides/microservices-tier.html#service-and-event-definitions-with-protocol-buffers">Service and Event Definitions with Protocol Buffers</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/microservices-tier.html#grpc-client-on-the-web-server">Grpc Client on the Web Server</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/microservices-tier.html#grpc-server-in-microservices">Grpc Server in Microservices</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/microservices-tier.html#pub-sub-messaging-and-other-supporting-infrastructure">Pub-Sub Messaging and Other Supporting Infrastructure</a>
              </li>
            
            </ul>
          </li>
          
          <li class="link-list-item">
            <a href="/docs/guides/service-discovery.html">Service Discovery with etcd</a>
            <ul>
            
              <li class="link-list-item">
                <a href="/docs/guides/service-discovery.html#querying-etcd">Querying etcd</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/service-discovery.html#registering-services-in-etcd">Registering services in etcd</a>
              </li>
            
            </ul>
          </li>
          
          <li class="link-list-item">
            <a href="/docs/guides/web-tier.html">Web Tier Implementation</a>
            <ul>
            
              <li class="link-list-item">
                <a href="/docs/guides/web-tier.html#web-client">Web Client</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/web-tier.html#web-server">Web Server</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/web-tier.html#web-client-and-server-communication-via-falcor">Web Client and Server Communication via Falcor</a>
              </li>
            
              <li class="link-list-item">
                <a href="/docs/guides/web-tier.html#session-storage-in-cassandra-datastax-enterprise">Session Storage in Cassandra / DataStax Enterprise</a>
              </li>
            
            </ul>
          </li>
          
        </ul>
      </nav>
    </div>
  </div>
</section>


  
  <footer class="footer">
    <div class="container level">
      <div class="level-left">
        <div class="level-item">
          <p>
            <strong>KillrVideo</strong> is open source and available under an 
            <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache 2.0</a> license.
          <p>
          <p>
            <small>Site version <a href="https://github.com/KillrVideo/killrvideo.github.io/commit/d2057ac9895991565a5e24020a938a0877c812c1" target="_blank">d2057ac</a></small>
          </p>
        </div>
      </div>
      <div class="level-right">
        <div class="level-right">
          <a class="button level-item" href="https://github.com/KillrVideo/killrvideo.github.io/tree/source/src/site/docs/guides/service-discovery.md" target="_blank">
            <i class="fa fa-github fa-fw"></i>Improve this page
          </a>
        </div>
      </div>
    </div>
  </footer>
  <script type="text/javascript" src="/assets/bundle.js"></script>
</body>
</html>